import { Auto, execPromise, getCurrentBranch, IPlugin, SEMVER } from '@auto-it/core';
import { inc, ReleaseType } from 'semver';
import { getLernaJson, isMonorepo } from '@auto-it/npm/dist/utils';
import { getMonorepoPackage, greaterRelease } from '@auto-it/npm';
import path from 'node:path';
import fs from 'node:fs';

const rootPath = path.join(__dirname, '../');
const envTs = path.join(rootPath, 'packages/utils/src/env.ts');
const manifestJson = path.join(rootPath, 'packages/extension-chrome/public/manifest.json');

function generateEnvTs(version: string, commitHash: string): string {
  return `// Do not edit this file, it is automatically updated in CI
export const LIB_VERSION = '${version}';
export const COMMIT_HASH = '${commitHash}';
`;
}

/**
 * This is a custom Auto plugin that updates the Nexus manifest and env.ts files when `auto shipit` is run.
 */
export default class UpdateVersion implements IPlugin {
  name = 'update-nexus-version';

  apply(auto: Auto): void {
    auto.hooks.version.tapPromise(this.name, async ({ dryRun, useVersion, bump }) => {
      if (dryRun) return;
      if (!isMonorepo()) throw new Error('Nexus seems changed');

      const monorepoVersion: string = getLernaJson().version;

      const isIndependent = monorepoVersion === 'independent';
      if (isIndependent) throw new Error('Nexus seems changed to independent versioning');

      const branch = getCurrentBranch();
      const isBaseBranch = branch === auto.baseBranch;

      const bumpedVersion =
        isIndependent || !isBaseBranch
          ? useVersion || bump
          : useVersion || (await bumpLatest(getMonorepoPackage(), bump)) || bump;

      const commitHash = await auto.git?.getSha();

      auto.logger.log.info(`Bump base branch: ${auto.baseBranch}, current branch: ${branch}`);
      auto.logger.log.info(`Nexus will bump the manifest to ${bumpedVersion} - ${commitHash}`);

      fs.writeFileSync(envTs, generateEnvTs(bumpedVersion, commitHash || 'unknown'));
      const oldManifest = JSON.parse(fs.readFileSync(manifestJson).toString());
      oldManifest.version = bumpedVersion;
      fs.writeFileSync(manifestJson, JSON.stringify(oldManifest, null, 2));

      await execPromise('npx', ['prettier', '-w', envTs, manifestJson]);
      await execPromise('git', ['add', envTs, manifestJson]);
      await execPromise('git', ['commit', '-m', `"Bump manifest version to: ${bumpedVersion} [skip ci]"`]);
    });
  }
}

/**
 * Increment the version number of a package based the bigger
 * release between the last published version and the version
 * in the package.json.
 */
async function bumpLatest({ version: localVersion, name }: IPackageJSON, version: SEMVER) {
  const latestVersion = localVersion ? await greaterRelease((s) => s, name, localVersion) : undefined;

  return latestVersion ? inc(latestVersion, version as ReleaseType) : version;
}

interface IPackageJSON {
  name: string;
  version: string;
}
